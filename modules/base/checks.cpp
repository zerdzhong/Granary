//
// Created by zhongzhendong on 2018-12-23.
//

#include "checks.hpp"

#if defined(ANDROID)
#define LOG_TAG_ANDROID "rtc"
#include <android/log.h>  // NOLINT
#endif

#if defined(WIN)
#include <windows.h>
#endif

#if defined(WIN)
#define LAST_SYSTEM_ERROR (::GetLastError())
#elif defined(__native_client__) && __native_client__
#define LAST_SYSTEM_ERROR (0)
#elif defined(POSIX)
#include <errno.h>
#define LAST_SYSTEM_ERROR (errno)
#endif

namespace granary {
    namespace granary_checks_impl {

        void AppendFormat(std::string* s, const char* fmt, ...) {
            va_list args, copy;
            va_start(args, fmt);
            va_copy(copy, args);
            const int predicted_length = std::vsnprintf(nullptr, 0, fmt, copy);
            va_end(copy);

            if (predicted_length > 0) {
                const size_t size = s->size();
                s->resize(size + predicted_length);
                std::vsnprintf(&((*s)[size]), static_cast<size_t>(predicted_length + 1), fmt, args);
            }
            va_end(args);
        }

        bool ParseArg(va_list* args, const CheckArgType** fmt, std::string* s) {
            if (**fmt == CheckArgType::kEnd)
                return false;

            switch (**fmt) {
                case CheckArgType::kInt:
                    AppendFormat(s, "%d", va_arg(*args, int));
                    break;
                case CheckArgType::kLong:
                    AppendFormat(s, "%ld", va_arg(*args, long));
                    break;
                case CheckArgType::kLongLong:
                    AppendFormat(s, "%lld", va_arg(*args, long long));
                    break;
                case CheckArgType::kUInt:
                    AppendFormat(s, "%u", va_arg(*args, unsigned));
                    break;
                case CheckArgType::kULong:
                    AppendFormat(s, "%lu", va_arg(*args, unsigned long));
                    break;
                case CheckArgType::kULongLong:
                    AppendFormat(s, "%llu", va_arg(*args, unsigned long long));
                    break;
                case CheckArgType::kDouble:
                    AppendFormat(s, "%g", va_arg(*args, double));
                    break;
                case CheckArgType::kLongDouble:
                    AppendFormat(s, "%Lg", va_arg(*args, long double));
                    break;
                case CheckArgType::kCharP:
                    s->append(va_arg(*args, const char*));
                    break;
                case CheckArgType::kStdString:
                    s->append(*va_arg(*args, const std::string*));
                    break;
                case CheckArgType::kVoidP:
                    AppendFormat(s, "%p", va_arg(*args, const void*));
                    break;
                default:
                    s->append("[Invalid CheckArgType]");
                    return false;
            }
            (*fmt)++;
            return true;
        }

        void FatalLog(const char* file,
                      int line,
                      const char* message,
                      const CheckArgType* fmt,
                      ...)
        {
            va_list args;
            va_start(args, fmt);
            std::string s;

            AppendFormat(&s,
                         "\n\n"
                         "#\n"
                         "# Fatal error in: %s, line %d\n"
                         "# last system error: %u\n"
                         "# Check failed: %s",
                         file, line, LAST_SYSTEM_ERROR, message);

            if (*fmt == CheckArgType::kCheckOp) {
                // This log message was generated by RTC_CHECK_OP, so we have to complete
                // the error message using the operands that have been passed as the first
                // two arguments.
                fmt++;

                std::string s1, s2;
                if (ParseArg(&args, &fmt, &s1) && ParseArg(&args, &fmt, &s2))
                    AppendFormat(&s, " (%s vs. %s)\n# ", s1.c_str(), s2.c_str());
            } else {
                s.append("\n# ");
            }

            // Append all the user-supplied arguments to the message.
            while (ParseArg(&args, &fmt, &s));
            va_end(args);
        }
    }
}

void FatalMessage(const char *file, int line, const char *msg) {
    static constexpr granary::granary_checks_impl::CheckArgType t[] = {
            granary::granary_checks_impl::CheckArgType::kEnd};
    FatalLog(file, line, msg, t);
}
